---
title: "Lesson_Graphs and Tables PSL374 2022"
author: "Brian Cox, with contributions from Frances Wong"
date: '2022-12-25'
output: html_document
---

Here are some quotes from famous statisticians

> "There are no routine statistical questions, only questionable statistical
> routines." --- Sir David Cox

> "Far better an approximate answer to the right question, which is often
> vague, than an exact answer to the wrong question, which can always be made
> precise." --- John Tukey

> "Reciting the magic phrase 'significant at the .01 level' is often a
>  substitute for hard thinking about the quality of one's data." 
	--- Selvin, 1958

> "Researchers should spend more time worrying about why they only have a
> significance of 0.05" -- Fisher

> "If you need statistics, you did the wrong experiment." --- Ernest Rutherford

Graphing data will make sure you are asking the correct question and applying the correct methods.


"**A graph is worth a thousands tables.**"
	-- Me


We will focus on generating different graphs using the *ggplot* library. This is a very versatile method of generating a very wide range of plots. There are many of ways of making graphs in R. To avoid confusion of these different methods I am focusing on one, you are free to explore others.

Before you can begin you must first install and open a libraries of code. This can be a bit confusing as the library is installed as a *package*, but then activated as a *library*.

The first package we will install is called tidyverse, it is made of many other package that integrate together and make the tidyverse.

Libraries
```{r library installs}
install.packages("fansi")

library(tidyverse)
library(ggplot2)
library(formattable)
library(DT)
library(kableExtra)

```


Of course now we will need some data to graph. I have selected a data set of breast cancer pathology measurements. The data can be found from the URL "https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/wdbc.data". Similar to last week, we have downloaded the table and we'll read it in to start working with it. 

```{r data loading}

# Modify the file path to your local file
#bCancer <- read_csv("breastCancerData.csv")

bCancer <- read.csv("breastCancerData.csv")


```


Some helpful information about the parameters described: 
	a) radius (mean of distances from center to points on the perimeter)
	b) texture (standard deviation of gray-scale values)
	c) perimeter
	d) area
	e) smoothness (local variation in radius lengths)
	f) compactness (perimeter^2 / area - 1.0)
	g) concavity (severity of concave portions of the contour)
	h) concave points (number of concave portions of the contour)
	i) symmetry 
	j) fractal dimension ("coastline approximation" - 1)

# Lets make a graph

Creating a plot in ggplot, comparing radisu on the x axis and concav on the y axis as a scatter plot. 

```{r}
ggplot(data = bCancer, mapping = aes(x = concav, y = radius)) +
  geom_point()
```


Lets examine the code to understand how this works.
R is structured like a language in that there are rules or a grammar that the computer expects.

ggplot(data = <DATA>, mapping = aes(<MAPPINGS>)) +
  <GEOM_FUNCTION>()

ggplot() is a function, and functions typically have curved brackets.

Functions need to be told what to work on, in this case, the data.

ggplot works by layers, each layer is separated by the '+'

The first line creates a ggplot object of the data. The second layer is setting the type of plot to make, a geom_point plot. Most ggplot layers begin with the geom_ then follow with something that describes the type of plots, lines, points, bars.

An essential part of the graphing process is the aes() function. This sets what the x and y axis will be. They are given the names of the columns from the data tables. In the first example x was set to radius and y was set to concav (whatever that is!).

**A note about mapping**
Mapping can be placed in multiple locations. Mapping can be placed in the ggplot function or in the geom_functions. If in the geom_functions it will give each graphing layer its own aesthetic control. This will be important later. 


# Adding details

Often we graph data that is from different types of samples. In our case the data has tumors that are either benign (less dangerous) or metastatic (very dangerous). By adding a shape or colour we can visualize if these sample types are different.  

Using aes() can also control the size, shape and colour of the data points. This is automated, the shapes, sizes and colours are selected by the computer, but you can customize these.

A more detailed graph

```{r}
ggplot(data = bCancer, mapping = aes(x = radius, y = concav, colour = diagnosis)) +
  geom_point()
```

Wow! Nice, using the aes() function we can set colors for the variables and have the figure legend added.

We can also change the labels of the axis and add a title to the figure. THere are several methods to do this, mostly to confuse people. 
Independently you can use ggtitle(), xlab(), ylab()
together you can use labs(...)
where you can set the title, x, y, subtitle and caption
The legend title can also be adjusted by using the methods that was applied to generate a legend, in this case colour.


```{r}
ggplot(data = bCancer, mapping = aes(x = radius, y = concav, colour = diagnosis)) +
  geom_point() +
	labs(title="Breast Cancer", 
			 subtitle = "Relationship to diagnosis", 
			 x = "Tumor radius", 
			 y = "Tumor concavity", 
			 colour="Tumour \ndiagnosis", 
			 caption = "A graphical comparison of tumour properties radius and concavity \nto the diagnsosis of benign (B) and malignant (M).")


```
If you would like even more control, Font size, colour etc. you can use the function theme(). You can investigate this on your own. For you assignments the default theme is acceptable. 

\n is an escape character. The \ will not be printed but tell the code that the letter following is special and codes for something. \n means new line

Colour can automatically recognize when you have a continuous or categorical data type. 

```{r}
# Make a separate plot of radius and smooth, set the shape to diagnosis and the colour to concav.
ggplot(data = bCancer, 
       mapping = aes(x = radius, y = concav, shape = diagnosis, 
                     color = perimeter)) +
  geom_point() +
  scale_color_gradient(low="blue", high="red") +
# add in labels and annotation
	labs(title="Breast Cancer", 
			 subtitle = "Relationship to diagnosis", 
			 x = "Tumor radius", 
			 y = "Tumor concavity", 
			 colour="Tumour \n perimeter", 
			 shape= "Tumor Diagnosis",
			 caption = "A graphical comparison of tumour properties radius and concavity \nto the diagnsosis of benign (B) and malignant (M).")
```
# Dual plots

Sometimes it is helpful to have plots side by side. To do this we can use facets. We can add a layer using the + and apply the facet_wrap() to split the data by diagnosis.

QUESTION::Why would be want to use a colour or facet to graph our data?

```{r}
ggplot(data = bCancer, mapping = aes(x = radius, y = concav)) +
  geom_point() +
# add facet_wrap
	facet_wrap(~diagnosis)
```
NOTE, if wrapping different variables, you may need to consider the scales of the data. It is possible that one blood measurement is in mg/ml and another in ug/ml (1000x difference in concentration). In these cases you can use the attribute scales="free".

# Variable types

There are different kinds of variables. We plotted continuous such as variables and concav. Categorical variables are very important, they have a set of fixed values, usually using text. In our cases *diagnosis* is a categorical variable. Samples can either be B (benign) or M (malignant). There are no other possible values. In R these are called factor data.

### Bar graphs
Bar graphs are for counting categorical data. How many of each category. These should never be used for continuous data or be graphed with error bars. A count is absolute. Bar graphs are created using the *geom_bar()* function and although a simple type of graph they can provide useful looks at a data set

Lets make one for the breast cancer data. Bar graphs are useful for categorical data, such as patient classes of sick and healthy. As the bar graph only has one variable (the categorical variable) the *aes()* function only needs to be given an *x* variable. The *y* variable is calculated automatically by counting the number of cases or events that match to the *x* variable.

```{r}
ggplot(bCancer, mapping = aes(x=diagnosis)) +
	geom_bar()+
	labs(title="Breast Cancer", 
			 subtitle = "counts of B vs M", 
			 x = "Tumor type", 
			 y = "patient numbers", 
			 caption = "A bar graph of benign (B) and malignant (M) counts.")
```

We can also make a continuous variable into a category by using the cut() function. Lets apply cut() against the variables radius and conPoints. First we need to decide where to split the variables. I would like to use the median. 

```{r}
#summary of the first 12 columns
summary(bCancer[,1:12])
```



```{r}
# creating bins from 0 to 13.4 and 13.5 to 30
rBins<-cut(bCancer$radius, breaks = c(0,13.4,30))

head(rBins)
summary(rBins)
```

This works but it is not generic, in that we have to set hard values each time we use a different variable. Let make this generic so we can change the variable. We can also change the bin labels so they are more understandable by people. 

```{r}
#the bins for radius
rBins<-cut(bCancer$radius, breaks = c(min(bCancer$radius), median(bCancer$radius)+0.01, max(bCancer$radius)), labels = c("Radius low", "Radius high"))
```

geom_bar() has an argument called position. Lets try using "dodge", "stack" and "fill".

```{r}
# A bar plot using position arguments
ggplot(bCancer, mapping = aes(x=rBins, fill= diagnosis)) +
	geom_bar(position ="dodge")
```

What if we have more categories we want to split the data? We can create another bin of conPoints and merge this with diagnosis using the paste() function. This will create the combined categories of B low, B high, M low and M high. 

```{r}
# the bins for conPoints
cBins<-cut(bCancer$conPoints, breaks = c(min(bCancer$conPoints), median(bCancer$conPoints), max(bCancer$conPoints)), labels = c("conPoints low", " conPoints high"))
```


Now lets remake the graph using paste to create a new fill category that combines the diagnosis with the conPoints bins of high and low. Lets also add some nicer labels and a caption that explains how the data was binned. 

```{r}

# A bar plot of the bins filled by diagnosis. NOTE not using colour 
ggplot(bCancer, mapping = aes(x=rBins, fill= paste(diagnosis, cBins))) +
	geom_bar(position = "fill") +
	labs(x="Radius Bin", 
			 y = "Count", 
			 fill = "Diagnosis and conPoints Bin", 
			 caption = "High low values are split by the median")

```

What do we see in this graph? 


### Histograms

Histograms give the distribution or density of data. It can only work for counts, so continuous data must be changed into categorical data. In the case of histograms we can call these bins. This is just like we created above using the cut() function. Like 0 to 5, 5.1 to 10, 10.1 to 15 etc. This is done automatically by a fitting routine, but you can set it manually. To make a histogram we use the geom_histogram() function. The bins argument is the total number of groups to cut the data into. 

```{r}

# a histogram of perimiter and diagnosis
ggplot(data=bCancer, mapping=aes(x= perimeter, fill=diagnosis)) +
	geom_histogram(bins=30)

```


### Density plot
Another method is to make a density plot using the geom_density() function. This creates lines that fits a density function. It looks like a histogram that has been smoothed.

```{r}
# a density plot of perimeter by diagnosis 
ggplot(bCancer, aes(x= perimeter, fill=diagnosis)) +
  geom_density() 

```


Notice that we used _fill=diagnosis_ to make a solid coloured graphs, we can also use _linetype=diagnosis_ and _colour=diagnosis_

# 2-dimensional density graphs
We can revisit the above graph and change it to a density graph

```{r}
ggplot(data = bCancer, mapping = aes(x = radius, y = concav, colour = diagnosis)) +
  geom_point() +
	labs(title="Breast Cancer", 
			 subtitle = "Relationship to diagnosis", 
			 x = "Tumor radius", 
			 y = "Tumor concavity", 
			 colour="Tumour \ndiagnosis", 
			 caption = "A graphical comparison of tumour properties radius and concavity \nto the diagnsosis of benign (B) and malignant (M).")

ggplot(data = bCancer, mapping = aes(x = radius, y = concav, colour = diagnosis)) +
  geom_density2d(binwidth= 0.25) +
	labs(title="Breast Cancer", 
			 subtitle = "Relationship to diagnosis", 
			 x = "Tumor radius", 
			 y = "Tumor concavity", 
			 colour="Tumour \ndiagnosis", 
			 caption = "A graphical comparison of tumour properties radius and concavity \nto the diagnsosis of benign (B) and malignant (M).")


```



### Jitter, Box and Violin plots
These plot help you understand the range of the data and its distribution, normally  or non-parametric. 

### EXERCISE # 1
Lets explore how geom_point(), geom_boxplot(), geom_jitter() and geom_violin() graph the diagnosis (x axis) and the radius (y axis). Create four graphs and discuss what each of the graph types tells you about the data. Is there one that is the best? 

Start by creating the ggplot of the bCancer data and setting the x value to diagnosis and y to radius. Then make the different graph types. 

### END of EXERCISE

## Lines and time series

Let's look at a different dataset. This data is a time series data set of maternal blood protein levels of placental growth factor during pregnancy in both normal and preeclamptic pregnancies.

Load the data
```{r}
#plgf<-read.csv("..//Lesson3_Graphing//plgfData.csv")
plgf <- read.csv("~/Documents/Courses/PLS4040/2020/graphing workspace/plgfData.csv")

head(plgf)
```

Let make plot of the gestational age in weeks (GA_wks) versus the PLGF serum levels (PGF_mat_serum)

```{r}
ggplot(data = plgf, mapping = aes(x = GA_wks, y = PGF_mat_serum, color=path)) +
	geom_point()
```

A popular method of graphing time series data is using line graphs. The lines denote a connection between the data points. We are justified using lines as these are the same person sampled at multiple time points. For the graph to interpret this relationship we need to group the data. This is accomplished using group attribute in the aes() function.

```{r}
ggplot(plgf, aes(x = GA_wks, y = PGF_mat_serum, group = pat_ID, colour= path)) + 
	geom_line()
```

As this is time series data we may like to know the trend line, or the average expression and confidence interval. This can be calculated automatically using the geom_smooth() function. Replace the geom_point() function with geom_smooth().

```{r}
ggplot(data = plgf,aes(x = GA_wks, y = PGF_mat_serum, colour=path)) +
	geom_smooth()
```

Now we will use a powerful part of ggplot() to add graph layers. Layers are literal and you can cover data if you do not add them in a desired order. 

```{r}
# points over smooth
ggplot(data = plgf,aes(x = GA_wks, y = PGF_mat_serum, colour=path)) +
	geom_smooth() +
		geom_point()

#smooth over points

ggplot(data = plgf,aes(x = GA_wks, y = PGF_mat_serum, colour=path)) +
	geom_point() +
	geom_smooth()
```

Note at this point all we have done is graph the data. Are these statistical differences? Likely, but we have not calculated them. This phase is call exploratory data analysis. We are learning about the data, which and how the variables relate to each other, do any variables look different between our classes? These are very important questions to ask. Graphing is important to apply in combination with calculating the means and the statistical differences between the means.

# Datasaurus Dozen

Lets explore how graphs and summary statistic are both importnat with another data set called the DatasaurusDozen.

```{r}
#datasaurus dozen
dd <- read.delim("DatasaurusDozen.tsv")

head(dd)
```

```{r}
summary(dd)
```

The column dataset is a categorical variable that divides the data set. There are 13 in total. Each subset has two columns of continuous variables x and y that range in values from 0 to 100 (well mostly).

Using split we can break up the dd table by data set and then calculate the means of X and Y for each data set. I am going to use some fancy nested code to do this. We learned about the apply() function that loops over tables by columns of rows. There is a related function called lapply(). The l is for list, this is an apply() function that works on list objects. I am also introducing a function called function(). This functions let you create functions. lapply is looping over the elements in the list object abd returning tables (data frames). To calculate the means we can using the apply() function as we did last class. But to pass the table to apply we need to provide a function. 

This code function(x) says to accept an object and call it x (we could call the object any name). Then use x in the apply function selecting columns 2 and 3 and calculate the mean by the column.
 
```{r}
#split in to datasets
ddList<- split(dd, dd$dataset)

ddList[[1]]
#use lapply to apply a function to each element of the list
#use apply on each list element to calculate the mean.
ddMeans<-lapply(ddList, FUN = function(x) apply(x[,2:3], MARGIN = 2, FUN =mean))

data.frame(ddMeans)
			 
```

##EXERCISE #2

1. Lets explore how graphing is an approach to data analysis that may complement statistical tests. With your group compare the x variables using a t.test() from the datasets "away" and "bullseye". Recall that you can select the elements of the list object ddList by their name. Using $away or [["away"]]. 

```{r}
t.test(ddList[["away"]]$x, ddList[["bullseye"]]$x)
```



2. Now make a graph of the same two data sets. Use geom_point()

```{r}

ggplot(data = ddList[["away"]], aes(x=x, y=y)) +
	geom_point()

ggplot(data = ddList[["bullseye"]], aes(x=x, y=y)) +
	geom_point()

```



3. Make another geom_point() graph using the facet_wrap() function to graph all the data sets from the dd object. Recall facet_wrap() need a function_of ~  the thing to separate graph by. 
```{r}
ggplot(data = dd, aes(x=x, y=y)) +
	geom_point() +
	facet_wrap(~dataset)
```


# END of EXERCISE

##Tables
Sometimes we need to make tables. We will use the library fromattable and kable to make formatted tables. There are many other packages for making formatted tables, you are welcome to explore these and use them. 

## Obtain the data

We will start with some current data that is still being collected. This is the publicly available data about COIVD-19 diagnosis and outcomes in Ontario. This data is maintained by Ontario Public Health and can be directly downloaded from their webpage. If the web access is not working I provided a file of this data form a few days ago. Depending if you use today's data or last weeks you may have slightly different values. 

```{r}
#retrieve data from the internet
covid<-read.csv("https://data.ontario.ca/dataset/f4112442-bdc8-45d2-be3c-12efae72fb27/resource/455fd63b-603d-4608-8216-7d8647f43350/download/conposcovidloc.csv")

#save a local copy, maybe put today's date in case you do this again and update it.
write.csv(covid, "Ontario_covid19_today.csv")

covid<-read.csv("Ontario_covid19_today.csv")

#Optionally you can save a R object of the data
save(file="covid.Rdata", covid)

#and then load an R object
load("covid.Rdata")

#what is in the table
head(covid)
```

This data contains several dates related to infection and detection, demographic information related to the ages, genders and locations of the individuals. 

Age_Group, Client_Gender, Reporting_PHU and others are categories. The dates are not categories they are dates, which are numeric ordinal data as the order is important. 

```{r}
summary(covid)
```
## Make some tables of the data

Lets explore how age and sex may affect outcomes from COVID19

Generate data.frames() of the data that are grouped by age, outcome and gender. The data is listed very long as it is daily cases in every reporting city in Ontario. To summarize tables of data a convient function is table().

A table of age and outcomes
```{r}
table(covid$Age_Group, covid$Outcome1)
```

This is a form of matrix so for easier handeling we wil convert it to a data frame using a special function called as.data.frame.matrix()

```{r}
covidAge<-as.data.frame.matrix(table(covid$Age_Group, covid$Outcome1))
```

Lets determine the fatality rate. This is the number of death divided by the total number of cases. This is a bit tricky as there is ongoing cases that are not resolved. I will exclude these as the outcome is not yet known. 

```{r}

covidAge$Fatal.Rate<-round(covidAge$Fatal/(covidAge$Resolved +covidAge$Fatal)*100,3)

covidAge
```

That is a dramatic increase due to age. What about gender? Table can group using multiple variables so we can add gender. However this will split the data into multiple tables for each category of gender. 

```{r}
table(covid$Age_Group, covid$Outcome1, covid$Client_Gender)
```


We can save this as an oject and extract the table of interest. Female and male are defined however very few clients declared gender diverse. Unspecified may be non cis gender, but its not known. For now we will have to use Female and Male.
Similar to data frames or matrix we can access using the [], but this table has three dimensions. 1st is row, 2nd is column and 3rd is gender or table number. Like this [row, column, table].

```{r}
#save the table/s
myTable<-table(covid$Age_Group, covid$Outcome1, covid$Client_Gender)

# look at one table
myTable[,,3]

# save specific table as a data frame, 1 is female and 3 is male

#female object 
covidFemale<- as.data.frame.matrix(myTable[,,1])
#delete misspelt object rm() is to remove
rm(coivdFemale)

#male object
covidMale <- as.data.frame.matrix(myTable[,,3])

```

## TRY THIS 

1. Calculate the fatality rate for females and males from the tables covidFamle and covidMale. Create a new column in the tables that holds the fatality rate

```{r}
#calculating the female fatality rate
covidAge$fem.fate.rate<-round(covidFemale$Fatal/(covidFemale$Resolved +covidFemale$Fatal)*100,3)

#claculating the male fatality rate
covidAge$mal.fate.rate<-round(covidMale$Fatal/(covidMale$Resolved +covidMale$Fatal)*100,3)

```


2. Make a new table with age as the row names and only the total fatality rate for all (we calculated together first in the table covidAge) and the fatality rates for males and females. Recall that the function rownames()  applied to a data.frame will return a character vector of the row names. the function data.frame() has an argument called row.names =, where you can provide a character vector of row names. 


3. Calculate a ratio of female to male fatality rates

```{r}
covidAge$ratio.FM.fat<-covidAge$mal.fate.rate/covidAge$fem.fate.rate
```


What does this tell us about age and sex as they relate to COVID19 deaths. 

## Formatting tables
Lets make the table look good for knitting. I am going to use the pipe command %>%. This sends the output of a line of code to the next line of code. This way you do not need to save each step as a new object and then put the object into the next function. There is a short cut to make %>% by pressing the command + shift + m keys at the same time.

To format the table we will use the kable() function from the kableExtra() library.

```{r}
covidAge %>% 
	#create a kable object from the data frame
	kable() %>% 
	#apply a style to the kable object
	kable_styling(full_width = F)
	
```

This immediately has a nicer format, with lines, bolded headings and is now scaled to fit on the page. 

There are many style options to try using the bootstrap_options argument in kable_styling(). Lets try striped

```{r}
covidAge %>% 
	#create a kable object from the data frame
	kable() %>% 
	#apply a style to the kable object
	kable_styling(full_width = F, bootstrap_options = "striped")
```

We can also set arguments in the kable() function to add captions (caption =) and new column names (col.names = ) as well as alignments (align = ) and significant digits (digits =).

```{r}
covidAge %>% 
kable(caption = "Fatality rates from COVID19, Ontario as of today",
			col.names = c("# fatal", "Not Resolved", "Resolved",  "Fatality Rate", 
										"Female Rate", 
										"Male Rate", 
										"Ratio Male to Female"),
			align="rcccccc", 
			digits=2) %>% 
	kable_styling(bootstrap_options = "striped", full_width = F)


```

You can also save a PDF version of a formatted table. You will need to install webshot and then use the function install_phantomjs(). This will bring in the function save_kable() that is added to the end of the code to print the output to a file. You use the file name to detrermine the output type. For example, save_kable("myPdf.pdf") would create a PDF. 

To create an interactive table you can use the datatable() function

```{r}
#library(DT)
covidAge %>% 
	datatable()
```

Another package is formattable that can add graphics to your tables. Here we can add a coloured bar or a tile that blends colors. 

```{r}
covidAge %>% 
formattable(list(
	fem.fate.rate = color_tile("lightblue", "yellow"),
	#fem.fate.rate = color_bar("pink"),
	mal.fate.rate = color_bar("green")
	)
	)
```


ASSIGNMENT # 2 GRAPHS AND TABLES

Due: TUESDAY JANURARY 26TH
---

# Conceptual questions
Complete this question on your own using short answers 1-2 sentences.

1. Why is graphing an important part of data analysis beyond statistical tests?

2. What graph would you use to compare a continuous variable split by a category?

# Coding questions 

For the assignment we will return to the heart study data set. After the code chunk be sure to assess the findings, was it significant/non-significant? At the end make any conclusions from your findings. You can work alone or in a small group of 2-3 people.

## Loading the data

```{r}
url<-"https://archive.ics.uci.edu/ml/machine-learning-databases/statlog/heart/heart.dat"

heart <- read.csv(url, sep=" ", header = F)
names <- c("age", "sex", "cp", "restbp", 
  "chol", "fbs", "restecg", "maxach", "exang", "oldpeak", "slope", "num", 
  "thal","disease")
heart<-data.frame(heart)
colnames(heart) <- names
heart.dat<-heart
heart.dat$sex <- factor(heart.dat$sex, labels=c("F", "M"))

heart.dat$cp <- factor(heart.dat$cp, 
  labels=c("Typ", "Atyp", "Non-Ang", "Asymp"))

heart.dat$fbs <- factor(heart.dat$fbs, labels=c("T", "F"))

heart.dat$restecg <- factor(heart.dat$restecg, 
  labels=c("Normal", "Abnorm", "Hypertrophy"))

heart.dat$exang <- factor(heart.dat$exang, labels=c("N", "Y"))

heart.dat$slope <- factor(heart.dat$slope, 
  labels=c("Up", "Flat", "Down"))

heart.dat$thal <- factor(heart.dat$thal, 
  labels=c("Normal", "Fixed", "Reversible"))

heart.dat$disease <- factor(heart.dat$disease, labels=c("H", "S"))
```


1. Graphically compare the relationship between age and the maximum heart rate achieved (maxach). Make an additional graph and colour the samples by disease status. 

2. Separate the heart.dat table by sex and again by disease. Make four linear models, lm() of age and maxach for each group of male and female and healthy and sick. Use age as the independent variable and maxach is the dependent variable. Recall that this is important to the order in the formula. This is four different models one for healthy one for sick for each of male and female patients. Report your findings in a formatted table (you can chose either kable() or formattable(), both are acceptable). Report the coefficients for intercept and age with the associated probabilities (Pr). Briefly, in two or three sentences interpret the findings. Are the relationships different or similar in health or sick populations?

3. For the categorical variables restecg and disease make a bar graph with appropriate labels and titles. The resting ECG value of abnormal is very rare. Make a table and perform a chi square test to determine if there is a significant dependence on disease.

4. Split the heart.dat table by sex and make box plots of cholesterol split by disease status. Perform an appropriate test to determine if cholesterol is different in sick cases compared to healthy. Breifly discuss if this significant in both females and males?


